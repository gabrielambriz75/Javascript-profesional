{"id":"ejercicios/generatos.html","dependencies":[{"name":"D:\\Angel\\source\\Repos\\Javascript-profesional\\package.json","includedInParent":true,"mtime":1642749196462}],"generated":{"html":"<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Closure</title>\r\n</head>\r\n\r\n<body>\r\n    <a href=\"/ejercicios/\">Go back</a>\r\n    <p><em>Abre la consola</em></p>\r\n\r\n\r\n\r\n    <script>var _marked = /*#__PURE__*/regeneratorRuntime.mark(simpleGenerator),\n    _marked2 = /*#__PURE__*/regeneratorRuntime.mark(idMaker),\n    _marked3 = /*#__PURE__*/regeneratorRuntime.mark(idMakerReset),\n    _marked4 = /*#__PURE__*/regeneratorRuntime.mark(fibonacci);\n\n// Los generadores son funciones de las que se puede salir y volver a entrar.\n// Su contexto (asociación de variables) será conservado entre las reentradas.\n// Cada vez que llamamos next, la ejecución del generador va a continuar hasta el proximo yield\nfunction simpleGenerator() {\n  return regeneratorRuntime.wrap(function simpleGenerator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          console.log(\"GENERATOR START\");\n          _context.next = 3;\n          return 1;\n\n        case 3:\n          _context.next = 5;\n          return 2;\n\n        case 5:\n          _context.next = 7;\n          return 3;\n\n        case 7:\n          console.log(\"GENERATOR END\");\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // const gen = simpleGenerator()\n// Podemos hacer generadores infinitos.\n\n\nfunction idMaker() {\n  var id;\n  return regeneratorRuntime.wrap(function idMaker$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          id = 1;\n\n        case 1:\n          if (!true) {\n            _context2.next = 7;\n            break;\n          }\n\n          _context2.next = 4;\n          return id;\n\n        case 4:\n          id++;\n          _context2.next = 1;\n          break;\n\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n} // Cuando llamamos next también podemos pasar valores que la función recibe.\n\n\nfunction idMakerReset() {\n  var id, reset;\n  return regeneratorRuntime.wrap(function idMakerReset$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          id = 1;\n\n        case 1:\n          if (!true) {\n            _context3.next = 8;\n            break;\n          }\n\n          _context3.next = 4;\n          return id;\n\n        case 4:\n          reset = _context3.sent;\n\n          if (reset) {\n            id = 1;\n          } else {\n            id++;\n          }\n\n          _context3.next = 1;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n} // Ahora hagamos un ejemplo un poco más complejo: la secuencia fibonacci\n\n\nfunction fibonacci() {\n  var a, b, nextNumber;\n  return regeneratorRuntime.wrap(function fibonacci$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          a = 1;\n          b = 1;\n\n        case 2:\n          if (!true) {\n            _context4.next = 10;\n            break;\n          }\n\n          nextNumber = a + b;\n          a = b;\n          b = nextNumber;\n          _context4.next = 8;\n          return nextNumber;\n\n        case 8:\n          _context4.next = 2;\n          break;\n\n        case 10:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}</script>\r\n\r\n</body>\r\n\r\n</html>"},"sourceMaps":null,"error":null,"hash":"39b45430a60e7ba04fa7651f5532ab29","cacheData":{"env":{}}}